# 内存模型与原子操作

- 内存模型定义了多线程程序中，读写操作如何在不同线程之间可见，以及这些操作在何种顺序下执行。内存模型确保程序的行为在并发环境下是可预测的。

- 原子操作即**不可分割的操作**。系统的所有线程，不可能观察到原子操作完成了一半。

最基础的概念就是如此，这里不再过多赘述，后续还会详细展开内存模型的问题。

## 原子操作

```cpp
int a = 0;
void f(){
    ++a;
}
```

显然，`++a` 是非原子操作，也就是说在多线程中可能会被另一个线程观察到只完成一半。

1. 线程 A 和线程 B 同时开始修改变量 `a` 的值。
2. 线程 A 对 `a` 执行递增操作，但还未完成。
3. 在线程 A 完成递增操作之前，线程 B 也执行了递增操作。
4. 线程 C 读取 `a` 的值。

线程 C 到底读取到多少不确定，a 的值是多少也不确定。显然，这构成了数据竞争，出现了[未定义行为](https://zh.cppreference.com/w/cpp/language/ub)。

在之前的内容中，我们讲述了使用很多同步设施，如互斥量，来保护共享资源。

```cpp
std::mutex m;
void f() {
    std::lock_guard<std::mutex> lc{ m };
    ++a;
}
```

通过互斥量的保护，即使 `++a` 本身不是原子操作，**逻辑上也可视为原子操作**。互斥量确保了对共享资源的读写是线程安全的，避免了数据竞争问题。

不过这显然不是我们的重点。我们想要的是一种**原子类型**，它的所有操作都直接是**原子**的，不需要额外的同步设施进行保护。C++11 引入了原子类型 [`std::atomic`](https://zh.cppreference.com/w/cpp/atomic/atomic)，在下节我们会详细讲解。

## 原子类型 `std::atomic`

标准原子类型定义在头文件 [`<atomic>`](https://zh.cppreference.com/w/cpp/header/atomic) 中。这些类型的操作都是原子的，语言定义中只有这些类型的操作是原子的，虽然也可以用互斥量来模拟原子操作（见上文）。标准的原子的类型实现可能是：*它们几乎都有一个 `is_lock_free()` 成员函数，这个函数可以让用户查询某原子类型的操作是直接用的原子指令（返回 `true`），还是内部用了锁实现（返回 `false`）。*

原子操作可以代替互斥量，来进行同步操作，也能带来更高的性能。但是如果它的内部使用互斥量实现，那么不可能有性能的提升。

在 C++17 中，所有原子类型都有一个 `static constexpr` 的数据成员 [`is_always_lock_free`](https://zh.cppreference.com/w/cpp/atomic/atomic/is_always_lock_free) 。如果当前环境上的原子类型 X 是无锁类型，那么 `X::is_always_lock_free` 将返回 `true` 。例如：

```cpp
std::atomic<int>::is_always_lock_free // true 或 false
```

标准库还提供了一组宏 [`ATOMIC_xxx_LOCK_FREE`](https://zh.cppreference.com/w/cpp/atomic/atomic_is_lock_free) ，在编译时对各种整数原子类型是否无锁进行判断。

```cpp
// (C++11 起)
#define ATOMIC_BOOL_LOCK_FREE     /* 未指定 */
#define ATOMIC_CHAR_LOCK_FREE     /* 未指定 */
#define ATOMIC_CHAR16_T_LOCK_FREE /* 未指定 */
#define ATOMIC_CHAR32_T_LOCK_FREE /* 未指定 */
#define ATOMIC_WCHAR_T_LOCK_FREE  /* 未指定 */
#define ATOMIC_SHORT_LOCK_FREE    /* 未指定 */
#define ATOMIC_INT_LOCK_FREE      /* 未指定 */
#define ATOMIC_LONG_LOCK_FREE     /* 未指定 */
#define ATOMIC_LLONG_LOCK_FREE    /* 未指定 */
#define ATOMIC_POINTER_LOCK_FREE  /* 未指定 */
// (C++20 起)
#define ATOMIC_CHAR8_T_LOCK_FREE  /* 未指定 */
```

- 对于一定**有锁**的内建原子类型是 0；
- 对于**有时无锁**的内建原子类型是 1；
- 对于一定**无锁**的内建原子类型是 2。

我们可以使用这些宏来对代码进行编译时的优化和检查，以确保在特定平台上原子操作的性能。例如，如果我们知道某些操作在目标平台上是无锁的，那么我们可以利用这一点进行性能优化。如果这些操作在目标平台上是有锁的，我们可能会选择其它同步机制。

```cpp
// 检查 std::atomic<int> 是否总是无锁
if constexpr(std::atomic<int>::is_always_lock_free) {
    std::cout << "当前环境 std::atomic<int> 始终是无锁" << std::endl;
}
else {
    std::cout << "当前环境 std::atomic<int> 并不总是无锁" << std::endl;
}

// 使用 ATOMIC_INT_LOCK_FREE 宏进行编译时检查
#if ATOMIC_INT_LOCK_FREE == 2
    std::cout << "int 类型的原子操作一定无锁的。" << std::endl;
#elif ATOMIC_INT_LOCK_FREE == 1
    std::cout << "int 类型的原子操作有时是无锁的。" << std::endl;
#else
    std::cout << "int 类型的原子操作一定有锁的。" << std::endl;
#endif
```

> [运行](https://godbolt.org/z/q5x7Wfd5r)测试。

如你所见，我们写了一个简单的示例，展示了如何使用 C++17 的静态数据成员 `is_always_lock_free` 和预处理宏来让程序执行不同的代码。

因为 `is_always_lock_free` 是编译期常量，所以我们可以使用 C++17 引入的 `constexpr if` ，它可以在编译阶段进行决策，避免了运行时的判断开销，提高了性能。

宏则更是简单了，最基本的预处理器判断，在预处理阶段就选择执行合适的代码。

在实际应用中，如果一个类型的原子操作总是无锁的，我们可以更放心地在性能关键的代码路径中使用它。例如，在高频交易系统、实时系统或者其它需要高并发性能的场景中，无锁的原子操作可以显著减少锁的开销和争用，提高系统的吞吐量和响应时间。

另一方面，如果发现某些原子类型在目标平台上是有锁的，我们可以考虑以下优化策略：

1. **使用不同的数据结构**：有时可以通过改变数据结构来避免对原子操作的依赖。
2. **减少原子操作的频率**：通过批处理等技术，减少对原子操作的调用次数。
3. **使用更高效的同步机制**：在一些情况下，其它同步机制（如读写锁）可能比原子操作更高效。

---

除了直接使用 `std::atomic` 模板外，也可以使用原子类型的别名。这个数量非常之多，见 [MSVC STL](https://github.com/microsoft/STL/blob/daeb0a6/stl/inc/atomic#L2745-L2805)。

对于标准内建类型的别名，就是在原子类型的类型名前面加上 `atomic_` 的前缀：`atomic_T`。不过 `signed` 缩写 `s`、`unsigned` 缩写 `u`、`long long` 缩写 `llong`。

```cpp
using atomic_char   = atomic<char>;
using atomic_schar  = atomic<signed char>;
using atomic_uchar  = atomic<unsigned char>;
using atomic_short  = atomic<short>;
using atomic_ushort = atomic<unsigned short>;
using atomic_int    = atomic<int>;
using atomic_uint   = atomic<unsigned int>;
using atomic_long   = atomic<long>;
using atomic_ulong  = atomic<unsigned long>;
using atomic_llong  = atomic<long long>;
using atomic_ullong = atomic<unsigned long long>;
```

---

通常 `std::atomic` 对象不可进行拷贝和赋值，因为它们的[拷贝构造](https://zh.cppreference.com/w/cpp/atomic/atomic/atomic)与[拷贝赋值运算符](https://zh.cppreference.com/w/cpp/atomic/atomic/operator%3D)被定义为[弃置](https://zh.cppreference.com/w/cpp/language/function#.E5.BC.83.E7.BD.AE.E5.87.BD.E6.95.B0)的。不过可以**隐式转换**成对应的内置类型，因为它有[转换函数](https://zh.cppreference.com/w/cpp/atomic/atomic/operator_T)。

```cpp
atomic(const atomic&) = delete;
atomic& operator=(const atomic&) = delete;
operator T() const noexcept;
```

可以使用 `load()`、`store()`、`exchange()`、`compare_exchange_weak()` 和 `compare_exchange_strong()` 等成员函数对 `std::atomic` 进行操作。如果是[整数类型](https://zh.cppreference.com/w/cpp/atomic/atomic#.E7.89.B9.E5.8C.96.E6.88.90.E5.91.98.E5.87.BD.E6.95.B0)的特化，还支持 `++`、`--`、`+=`、`-=`、`&=`、`|=`、`^=` 、`fetch_add`、`fetch_sub` 等操作方式。在后面详细的展开使用。

`std::atomic` 类模板不仅只能使用标准库为我们定义的特化类型，我们也完全可以自定义类型创建对应的原子对象。不过因为是通用模板，操作仅限 `load()`、`store()`、`exchange()`、`compare_exchange_weak()` 、 `compare_exchange_strong()`，以及一个转换函数。

模板 `std::atomic` 可用任何满足[*可复制构造 (CopyConstructible)*](https://zh.cppreference.com/w/cpp/named_req/CopyConstructible)及[*可复制赋值 (CopyAssignable)*](https://zh.cppreference.com/w/cpp/named_req/CopyAssignable)的[*可平凡复制 (TriviallyCopyable)*](https://zh.cppreference.com/w/cpp/named_req/TriviallyCopyable)类型 `T` 实例化。

```cpp
struct trivial_type {
    int x{};
    float y{};

    trivial_type() {}

    trivial_type(int a, float b) : x{ a }, y{ b } {}

    trivial_type(const trivial_type& other) = default;

    trivial_type& operator=(const trivial_type& other) = default;

    ~trivial_type() = default;
};
```

验证自己的类型是否满足 `std::atomic` 要求，我们可以这样做：

```cpp
std::cout << std::boolalpha << std::is_trivially_copyable<trivial_type>::value << '\n';
std::cout << std::boolalpha << std::is_copy_constructible<trivial_type>::value << '\n';
std::cout << std::boolalpha << std::is_move_constructible<trivial_type>::value << '\n';
std::cout << std::boolalpha << std::is_copy_assignable<trivial_type>::value << '\n';
std::cout << std::boolalpha << std::is_move_assignable<trivial_type>::value << '\n';
```

只要全部为 `true` 即可。显然我们的类型满足要求，我们可以尝试使用一下它：

```cpp
// 创建一个 std::atomic<trivial_type> 对象
std::atomic<trivial_type> atomic_my_type { trivial_type{ 10, 20.5f } };

// 使用 store 和 load 操作来设置和获取值
trivial_type new_value{ 30, 40.5f };
atomic_my_type.store(new_value);

trivial_type loadedValue = atomic_my_type.load();
std::cout << "x: " << loadedValue.x << ", y: " << loadedValue.y << std::endl;

// 使用 exchange 操作
trivial_type exchanged_value = atomic_my_type.exchange(trivial_type{ 50, 60.5f });
std::cout << "交换前的 x: " << exchanged_value.x << ", 交换前的 y: " << exchanged_value.y << std::endl;
std::cout << "交换后的 x: " << atomic_my_type.load().x << ", 交换后的 y: " << atomic_my_type.load().y << std::endl;
```

> [运行](https://godbolt.org/z/eTW64nGMz)测试。

没有问题，不过其实我们的 `trivial_type` 直接改成：

```cpp
struct trivial_type {
    int x;
    float y;
};
```

> [运行](https://godbolt.org/z/4oTf996xK)测试。

也是完全可以的，满足要求。先前只是为了展示一下显式写明的情况。

---

原子类型的每个操作函数，都有一个内存序参数，这个参数可以用来指定执行顺序，在后面的内容会详细讲述，现在只需要知道操作分为三类：

1. **Store 操作（存储操作）**：可选的内存序包括 `memory_order_relaxed`、`memory_order_release`、`memory_order_seq_cst`。

2. **Load 操作（加载操作）**：可选的内存序包括 `memory_order_relaxed`、`memory_order_consume`、`memory_order_acquire`、`memory_order_seq_cst`。

3. **Read-modify-write（读-改-写）操作**：可选的内存序包括 `memory_order_relaxed`、`memory_order_consume`、`memory_order_acquire`、`memory_order_release`、`memory_order_acq_rel`、`memory_order_seq_cst`。

## `st::atomic_flag`

`std::atomic_flag` 是最简单的原子类型，这个类型的对象可以在两个状态间切换：**设置（true）**和**清除（false）**。它很简单，通常只是用作构建一些库设施，不会单独使用或直接面向普通开发者。

在 C++20 之前，`std::atomic_flag` 类型的对象需要以 [`ATOMIC_FLAG_INIT`](https://zh.cppreference.com/w/cpp/atomic/ATOMIC_FLAG_INIT) 初始化，可以确保此时对象处于
"清除"（false）状态。

```cpp
std::atomic_flag f = ATOMIC_FLAG_INIT;
```

在 `C++20` 中 `std::atomic_flag` 的默认[构造函数](https://zh.cppreference.com/w/cpp/atomic/atomic_flag/atomic_flag)保证对象为“清除”（false）状态，就不再需要使用 `ATOMIC_FLAG_INIT`。

`ATOMIC_FLAG_INIT` 其实并不是什么复杂的东西，它在不同的标准库实现中只是简单的初始化：在 [`MSVC STL`](https://github.com/microsoft/STL/blob/daeb0a6/stl/inc/atomic#L2807-L2808) 它只是一个 `{}`，在 [`libstdc++`](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/atomic_base.h) 与 [`libc++`](https://github.com/llvm/llvm-project/blob/00e80fb/clang/lib/Headers/stdatomic.h#L169) 它只是一个 `{ 0 }`。也就是说我们可以这样初始化：

```cpp
std::atomic_flag f ATOMIC_FLAG_INIT;
std::atomic_flag f2 = {};
std::atomic_flag f3{};
std::atomic_flag f4{ 0 };
```

使用 ATOMIC_FLAG_INIT 宏只是为了统一，我们知道即可。

当标志对象已初始化，它只能做三件事情：**销毁、清除、设置**。这些操作对应的函数分别是：

1. **`clear()`** （清除）：将标志对象的状态原子地更改为清除（false）
2. **`test_and_set`**（测试并设置）：将标志对象的状态原子地更改为设置（true），并返回它先前保有的值。
3. **销毁**：对象的生命周期结束时，自动调用析构函数进行销毁操作。

每个操作都可以指定内存顺序。`clear()` 是一个“读-改-写”操作，可以应用任何内存顺序。默认的内存顺序是 `memory_order_seq_cst`。例如：

```cpp
f.clear(std::memory_order_release);
bool r = f.test_and_set();
```

1. 将 `f` 的状态原子地更改为清除（false），指明 `memory_order_release` 内存序。

2. 将 `f` 的状态原子地更改为设置（true），并返回它先前保有的值给 `r`。使用默认的 `memory_order_seq_cst` 内存序。

> 不用着急，这里还不是详细展开聊内存序的时候。

`std::atomic_flag` [不可复制](https://zh.cppreference.com/w/cpp/atomic/atomic_flag/atomic_flag)不可移动[不可赋值](https://zh.cppreference.com/w/cpp/atomic/atomic_flag/operator%3D)。这不是 `std::atomic_flag` 特有的，而是所有原子类型共有的属性。原子类型的所有操作都是原子的，而赋值和拷贝涉及两个对象，破坏了操作的原子性。拷贝构造和拷贝赋值会先读取第一个对象的值，然后再写入另一个对象。对于两个独立的对象，这里实际上有两个独立的操作，合并这两个操作无法保证其原子性。因此，这些操作是不被允许的。

有限的特性使得 `std::atomic_flag` 非常适合用作制作**自旋锁**。

```cpp
class spinlock_mutex {
    std::atomic_flag flag{};
public:
    void lock() {
        while (flag.test_and_set(std::memory_order_acquire));
    }

    void unlock() {
        flag.clear(std::memory_order_release);
    }
};
```

我们可以简单的使用测试一下，它是有效的：

```cpp
spinlock_mutex m;

void f(){
    std::lock_guard<spinlock_mutex> lc{ m };
    std::cout << "😅😅" << "❤️❤️\n";
}
```

> [运行](https://godbolt.org/z/9rs9sxsns)测试。

稍微聊一下原理，我们的 `spinlock_mutex` 对象中存储的 `flag` 对象在默认构造时是清除 (`false`) 状态。在 `lock()` 函数中调用 `test_and_set` 函数，它是原子的，只有一个线程能成功调用并将 `flag` 的状态原子地更改为设置 (`true`)，并返回它先前的值 (`false`)。此时，该线程成功获取了锁，退出循环。

当 `flag` 对象的状态为设置 (`true`) 时，其线程调用 `test_and_set` 函数会返回 `true`，导致它们继续在循环中自旋，无法退出。直到先前持有锁的线程调用 `unlock()` 函数，将 `flag` 对象的状态原子地更改为清除 (`false`) 状态。此时，等待的线程中会有一个线程成功调用 `test_and_set` 返回 `false`，然后退出循环，成功获取锁。

`std::atomic_flag` 的局限性太强，甚至不能当普通的 bool 标志那样使用。一般最好使用 `std::atomic<bool>`，下节，我们来使用它。
