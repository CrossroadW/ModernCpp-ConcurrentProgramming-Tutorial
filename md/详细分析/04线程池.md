# 线程池

## 前言

我相信，已经阅读到这里的各位，不会对“*线程池*”这个词感到陌生。大部分开发者早就自己使用、学习，乃至实现过线程池。那不如我们先来进行一下基础的名词解释。

- ***什么叫线程池？***

“**线程**”没什么好说的，是 CPU 调度的最小单位，也是操作系统的一种抽象资源。

“**池**”？水池装着水，线程池则是装着线程，是一种抽象的指代。

抽象的来说，可以当做是一个池子中存放了一堆线程，**故称作线程池**。简而言之，线程池是指代一组**预先创建的**、**可以复用的线程集合**。这些线程由线程池管理，用于执行多个任务而**无需频繁地创建和销毁**线程。

```mermaid
graph TD
    subgraph 线程池
        线程1
        线程2
        线程3
        线程4
        线程5
        ...
    end

    任务队列[任务队列]
    调度器 --> 线程1
    调度器 --> 线程2
    调度器 --> 线程3
    调度器 --> 线程4
    调度器 --> 线程5

    任务1 --> 调度器
    任务2 --> 调度器
    任务3 --> 调度器
    任务4 --> 调度器
    任务5 --> 调度器
    任务6 --> 调度器
    任务7 --> 调度器

    线程1 --> 执行任务1[执行任务1]
    线程2 --> 执行任务2[执行任务2]
    线程3 --> 执行任务3[执行任务3]
    线程4 --> 执行任务4[执行任务4]
    线程5 --> 执行任务5[执行任务5]

    执行任务1 --> 休眠1[休眠等待]
    执行任务2 --> 休眠2[休眠等待]
    执行任务3 --> 休眠3[休眠等待]
    执行任务4 --> 休眠4[休眠等待]
    执行任务5 --> 休眠5[休眠等待]

    任务6 --> 调度器 --> 唤醒线程1[唤醒线程1]
    唤醒线程1 -.-> 线程1
    线程1 --> 执行任务6[执行任务6]
    执行任务6 --> 休眠1

    任务7 --> 调度器 --> 唤醒线程2[唤醒线程2]
    唤醒线程2 -.-> 线程2
    线程2 --> 执行任务7[执行任务7]
    执行任务7 --> 休眠2

```

> 这是一个典型的线程池结构。线程池包含一个**任务队列**，当有新任务加入时，调度器会将任务分配给线程池中的空闲线程进行执行。线程在执行完任务后会进入**休眠状态**，等待**调度器**的下一次**唤醒**。当有新的任务加入队列，并且有线程处于休眠状态时，调度器会唤醒休眠的线程，并分配新的任务给它们执行。线程执行完新任务后，会再次进入休眠状态，直到有新的任务到来，调度器**才可能**会再次唤醒它们。
>
> 图中线程1 就是被调度器分配了任务1，执行完毕后休眠，然而新任务的到来让调度器再次将它唤醒，去执行任务6，执行完毕后继续休眠。

使用线程池的益处我们已经加粗了，然而这其实并不是“*线程池*”独有的，任何创建和销毁存在较大开销的设施，都可以进行所谓的“***池化***”。

常见的还有：**套接字连接池**、**数据库连接池**、**内存池**、**对象池**。

---

了解以上这些基础概念是第一步也是最后一步，随着水平的提升，对这些概念认知与理解也会逐渐提升。

## 市面上常规的线程池

在了解了线程池的基本概念与运行逻辑后，我们不用着急就尝试实现。我们可以先来聊一聊，使用一下市面上常见的那些线程池设施，了解它们的使用感受，接口设计的方式。

如 **`boost::asio::thread_pool`**、**`QThreadPool`**、`PPL`

## 实现线程池

实现一个普通的能够满足日常开发需求的线程池实际上非常简单，也只需要一百多行代码。
